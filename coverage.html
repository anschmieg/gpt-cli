
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gpt-cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/anschmieg/gpt-cli/cli.go (53.1%)</option>
				
				<option value="file1">github.com/anschmieg/gpt-cli/config.go (37.5%)</option>
				
				<option value="file2">github.com/anschmieg/gpt-cli/core.go (76.3%)</option>
				
				<option value="file3">github.com/anschmieg/gpt-cli/main.go (0.0%)</option>
				
				<option value="file4">github.com/anschmieg/gpt-cli/markdown.go (88.1%)</option>
				
				<option value="file5">github.com/anschmieg/gpt-cli/mock_server.go (87.1%)</option>
				
				<option value="file6">github.com/anschmieg/gpt-cli/providers.go (75.9%)</option>
				
				<option value="file7">github.com/anschmieg/gpt-cli/streaming.go (68.8%)</option>
				
				<option value="file8">github.com/anschmieg/gpt-cli/suggestions.go (79.2%)</option>
				
				<option value="file9">github.com/anschmieg/gpt-cli/test_helpers.go (92.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "strings"
)

// CLIConfig represents the configuration parsed from CLI arguments
type CLIConfig struct {
        Provider      string
        Model         string
        Temperature   float64
        System        string
        File          string
        Verbose       bool
        Markdown      bool
        RetryModel    bool
        Stream        bool
        Suggest       bool
        Help          bool
        Prompt        string
}

// parseArgs parses command line arguments and returns a CLIConfig
func parseArgs(args []string) (*CLIConfig, error) <span class="cov8" title="1">{
        config := &amp;CLIConfig{
                Provider:    "copilot",           // Default provider
                Temperature: 0.6,                // Default temperature
                Verbose:     false,              // Default verbose
                Markdown:    true,               // Default markdown enabled
                RetryModel:  false,              // Default retry disabled
        }

        fs := flag.NewFlagSet("gpt-cli", flag.ContinueOnError)
        fs.StringVar(&amp;config.Provider, "provider", config.Provider, "API provider (openai, gemini, copilot, etc)")
        fs.StringVar(&amp;config.Model, "model", "", "Model name")
        fs.Float64Var(&amp;config.Temperature, "temperature", config.Temperature, "Temperature (float)")
        fs.StringVar(&amp;config.System, "system", "", "System prompt")
        fs.StringVar(&amp;config.File, "file", "", "File to upload")
        fs.BoolVar(&amp;config.Verbose, "verbose", config.Verbose, "Enable verbose logging")
        fs.BoolVar(&amp;config.Markdown, "markdown", config.Markdown, "Enable markdown output")
        fs.BoolVar(&amp;config.RetryModel, "retry-model", config.RetryModel, "Retry with default model if specified model fails")
        fs.BoolVar(&amp;config.Stream, "stream", config.Stream, "Enable streaming output")
        fs.BoolVar(&amp;config.Suggest, "suggest", config.Suggest, "Shell suggestion mode - output structured JSON suggestions")
        fs.BoolVar(&amp;config.Help, "help", config.Help, "Show help")
        fs.BoolVar(&amp;config.Help, "h", config.Help, "Show help")

        if err := fs.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Join remaining arguments as the prompt
        <span class="cov8" title="1">config.Prompt = strings.Join(fs.Args(), " ")

        return config, nil</span>
}

// printHelp prints the help message
func printHelp() <span class="cov0" title="0">{
        fmt.Println(`gpt-cli: Portable GPT API Wrapper

Usage: gpt-cli [options] &lt;prompt&gt;

Options:
  --provider     API provider (openai, gemini, etc)
  --model        Model name
  --temperature  Temperature (float)
  --system       System prompt
  --file         File to upload
  --verbose      Enable verbose logging
  --markdown     Enable markdown output (default: true)
  --retry-model  Retry with default model if specified model fails
  --stream       Enable streaming output
  --suggest      Shell suggestion mode - output structured JSON suggestions
  -h, --help     Show help`)
}</span>

// runCLI is the main CLI entry point
func runCLI(args []string) error <span class="cov0" title="0">{
        config, err := parseArgs(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.Help || config.Prompt == "" </span><span class="cov0" title="0">{
                printHelp()
                return nil
        }</span>

        // Load configuration file if it exists
        <span class="cov0" title="0">fileConfig, _ := LoadConfig()
        ApplyConfigDefaults(config, fileConfig)

        // Create core config and run
        coreConfig := &amp;CoreConfig{
                Provider:       config.Provider,
                Model:          config.Model,
                Temperature:    config.Temperature,
                System:         config.System,
                File:           config.File,
                Verbose:        config.Verbose,
                AutoRetryModel: config.RetryModel,
                Prompt:         config.Prompt,
                UseMarkdown:    config.Markdown,
                Stream:         config.Stream,
                SuggestMode:    config.Suggest,
        }

        // Build provider options from environment
        providerOpts, err := buildProviderOptions(config.Provider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Run the core logic
        <span class="cov0" title="0">return runCore(coreConfig, providerOpts)</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "os"
        "path/filepath"
)

// Config represents the configuration file structure
type Config struct {
        DefaultProvider    string            `json:"default_provider,omitempty"`
        DefaultModel       string            `json:"default_model,omitempty"`
        DefaultTemperature float64           `json:"default_temperature,omitempty"`
        DefaultSystem      string            `json:"default_system,omitempty"`
        ProviderSettings   map[string]string `json:"provider_settings,omitempty"`
}

// LoadConfig loads configuration from ~/.gpt-cli/config.json if it exists
func LoadConfig() (*Config, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Config{}, nil // Return empty config if can't get home dir
        }</span>

        <span class="cov8" title="1">configPath := filepath.Join(homeDir, ".gpt-cli", "config.json")
        
        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;Config{}, nil // Return empty config if file doesn't exist
        }</span>

        // Read and parse config file
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Config{}, nil // Return empty config if can't read file
        }</span>

        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return &amp;Config{}, nil // Return empty config if can't parse JSON
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// SaveConfig saves configuration to ~/.gpt-cli/config.json
func SaveConfig(config *Config) error <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">configDir := filepath.Join(homeDir, ".gpt-cli")
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(configDir, "config.json")
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(configPath, data, 0644)</span>
}

// ApplyConfigDefaults applies configuration defaults to CLI config
func ApplyConfigDefaults(cliConfig *CLIConfig, fileConfig *Config) <span class="cov8" title="1">{
        if cliConfig.Provider == "copilot" &amp;&amp; fileConfig.DefaultProvider != "" </span><span class="cov8" title="1">{
                cliConfig.Provider = fileConfig.DefaultProvider
        }</span>
        <span class="cov8" title="1">if cliConfig.Model == "" &amp;&amp; fileConfig.DefaultModel != "" </span><span class="cov8" title="1">{
                cliConfig.Model = fileConfig.DefaultModel
        }</span>
        <span class="cov8" title="1">if cliConfig.Temperature == 0.6 &amp;&amp; fileConfig.DefaultTemperature != 0 </span><span class="cov8" title="1">{
                cliConfig.Temperature = fileConfig.DefaultTemperature
        }</span>
        <span class="cov8" title="1">if cliConfig.System == "" &amp;&amp; fileConfig.DefaultSystem != "" </span><span class="cov0" title="0">{
                cliConfig.System = fileConfig.DefaultSystem
        }</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "strings"
)

// CoreConfig represents the configuration for the core processing logic
type CoreConfig struct {
        Provider       string
        Model          string
        Temperature    float64
        System         string
        File           string
        Verbose        bool
        AutoRetryModel bool
        Prompt         string
        UseMarkdown    bool
        Stream         bool
        SuggestMode    bool
}

// ProviderOptions contains options passed to provider adapters
type ProviderOptions struct {
        APIKey  string
        BaseURL string
}

// ProviderResponse represents the response from a provider
type ProviderResponse struct {
        Text     string
        Markdown string
}

// buildProviderOptions creates provider options based on environment variables
func buildProviderOptions(provider string) (*ProviderOptions, error) <span class="cov8" title="1">{
        provider = strings.ToLower(provider)
        opts := &amp;ProviderOptions{}

        switch provider </span>{
        case "openai":<span class="cov8" title="1">
                opts.APIKey = os.Getenv("OPENAI_API_KEY")
                opts.BaseURL = os.Getenv("OPENAI_API_BASE")</span>
        case "copilot":<span class="cov8" title="1">
                opts.APIKey = os.Getenv("COPILOT_API_KEY")
                opts.BaseURL = os.Getenv("COPILOT_API_BASE")</span>
        case "gemini":<span class="cov8" title="1">
                opts.APIKey = os.Getenv("GEMINI_API_KEY")</span>
                // Gemini doesn't use custom base URLs typically
        }

        <span class="cov8" title="1">return opts, nil</span>
}

// getDefaultModel returns the default model for a given provider
func getDefaultModel(provider string) string <span class="cov8" title="1">{
        provider = strings.ToLower(provider)
        switch provider </span>{
        case "gemini":<span class="cov8" title="1">
                return "gemini-2.0-flash"</span>
        default:<span class="cov8" title="1">
                return "gpt-4o-mini"</span> // Global default
        }
}

// runCore is the main orchestration function that handles provider calls and output
func runCore(config *CoreConfig, providerOpts *ProviderOptions) error <span class="cov8" title="1">{
        // Handle suggestion mode separately
        if config.SuggestMode </span><span class="cov8" title="1">{
                return runSuggestionMode(config, providerOpts)
        }</span>

        // Set default system prompt if not provided
        <span class="cov8" title="1">if config.System == "" </span><span class="cov8" title="1">{
                config.System = "You are an AI assistant called via CLI. Respond concisely and clearly, focusing only on the user's prompt. Include only very brief explanations unless explicitly asked."
        }</span>

        // Set default model if not provided
        <span class="cov8" title="1">if config.Model == "" </span><span class="cov0" title="0">{
                config.Model = getDefaultModel(config.Provider)
        }</span>

        <span class="cov8" title="1">if config.Verbose </span><span class="cov8" title="1">{
                log.Printf("Config: Provider=%s, Model=%s, Temperature=%f, Prompt=%s",
                        config.Provider, config.Model, config.Temperature, config.Prompt)
        }</span>

        // Try streaming first if requested
        <span class="cov8" title="1">if config.Stream </span><span class="cov8" title="1">{
                if err := tryStreamingProvider(config, providerOpts); err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                // Fall back to non-streaming if streaming fails
                <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                        log.Printf("Streaming failed, falling back to non-streaming")
                }</span>
        }

        // Non-streaming path
        <span class="cov8" title="1">response, err := callProvider(config, providerOpts)
        if err != nil </span><span class="cov8" title="1">{
                // Handle model not supported error with retry
                if config.AutoRetryModel &amp;&amp; isModelNotSupportedError(err) </span><span class="cov0" title="0">{
                        if config.Verbose </span><span class="cov0" title="0">{
                                log.Printf("Model not supported, retrying without model...")
                        }</span>
                        // Retry without explicit model
                        <span class="cov0" title="0">retryConfig := *config
                        retryConfig.Model = ""
                        response, err = callProvider(&amp;retryConfig, providerOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%v (after retry)", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        return err
                }</span>
        }

        <span class="cov8" title="1">if config.Verbose </span><span class="cov8" title="1">{
                log.Printf("Raw response: Text=%d chars, Markdown=%d chars", 
                        len(response.Text), len(response.Markdown))
        }</span>

        // Output response based on markdown preference
        <span class="cov8" title="1">if !config.UseMarkdown </span><span class="cov8" title="1">{
                // Prefer text, fall back to markdown
                if response.Text != "" </span><span class="cov8" title="1">{
                        fmt.Print(response.Text)
                }</span> else<span class="cov0" title="0"> {
                        // Even for non-markdown preference, render markdown nicely
                        renderer := NewMarkdownRenderer(false) // No colors for plain text mode
                        fmt.Print(renderer.Render(response.Markdown))
                }</span>
        } else<span class="cov8" title="1"> {
                // Prefer markdown, fall back to text
                if response.Markdown != "" </span><span class="cov8" title="1">{
                        // Render markdown with ANSI formatting
                        renderer := NewMarkdownRenderer(true) // Enable colors for markdown mode
                        fmt.Print(renderer.Render(response.Markdown))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Print(response.Text)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isModelNotSupportedError checks if an error indicates model not supported
func isModelNotSupportedError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        return strings.Contains(errStr, "model_not_supported") ||
                strings.Contains(errStr, "model is not supported") ||
                strings.Contains(errStr, "requested model is not supported")</span>
}

// tryStreamingProvider attempts to use streaming API - now implemented in streaming.go

// callProvider calls the appropriate provider adapter
func callProvider(config *CoreConfig, providerOpts *ProviderOptions) (*ProviderResponse, error) <span class="cov8" title="1">{
        provider := strings.ToLower(config.Provider)
        
        switch provider </span>{
        case "openai":<span class="cov8" title="1">
                return callOpenAIProvider(config, providerOpts)</span>
        case "copilot":<span class="cov8" title="1">
                return callCopilotProvider(config, providerOpts)</span>
        case "gemini":<span class="cov0" title="0">
                return callGeminiProvider(config, providerOpts)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported provider: %s", config.Provider)</span>
        }
}</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) == 1 </span><span class="cov0" title="0">{
                fmt.Println("Hello from Go CLI!")
                return
        }</span>

        // Parse CLI arguments and run the core logic
        <span class="cov0" title="0">if err := runCLI(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "regexp"
        "strings"
)

// ANSI color codes for terminal formatting
const (
        Reset     = "\033[0m"
        Bold      = "\033[1m"
        Dim       = "\033[2m"
        Italic    = "\033[3m"
        Underline = "\033[4m"
        
        // Colors
        Red     = "\033[31m"
        Green   = "\033[32m"
        Yellow  = "\033[33m"
        Blue    = "\033[34m"
        Magenta = "\033[35m"
        Cyan    = "\033[36m"
        White   = "\033[37m"
        
        // Bright colors
        BrightRed     = "\033[91m"
        BrightGreen   = "\033[92m"
        BrightYellow  = "\033[93m"
        BrightBlue    = "\033[94m"
        BrightMagenta = "\033[95m"
        BrightCyan    = "\033[96m"
        BrightWhite   = "\033[97m"
)

// MarkdownRenderer handles converting markdown to ANSI-formatted terminal output
type MarkdownRenderer struct {
        colorOutput bool
}

// NewMarkdownRenderer creates a new markdown renderer
func NewMarkdownRenderer(colorOutput bool) *MarkdownRenderer <span class="cov8" title="1">{
        return &amp;MarkdownRenderer{
                colorOutput: colorOutput,
        }
}</span>

// Render converts markdown text to ANSI-formatted terminal output
func (r *MarkdownRenderer) Render(markdown string) string <span class="cov8" title="1">{
        if !r.colorOutput </span><span class="cov0" title="0">{
                // If color is disabled, just clean up markdown syntax
                return r.stripMarkdown(markdown)
        }</span>
        
        <span class="cov8" title="1">text := markdown
        
        // Process in order of specificity (most specific first)
        text = r.renderCodeBlocks(text)
        text = r.renderInlineCode(text)
        text = r.renderHeaders(text)
        text = r.renderBold(text)
        text = r.renderItalic(text)
        text = r.renderStrikethrough(text)
        text = r.renderLists(text)
        text = r.renderLinks(text)
        text = r.renderBlockquotes(text)
        
        return text</span>
}

// renderHeaders converts markdown headers to ANSI formatted headers
func (r *MarkdownRenderer) renderHeaders(text string) string <span class="cov8" title="1">{
        lines := strings.Split(text, "\n")
        var result []string
        
        for _, line := range lines </span><span class="cov8" title="1">{
                // Handle ATX headers (# ## ###)
                if strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        level := 0
                        for i, char := range line </span><span class="cov8" title="1">{
                                if char == '#' </span><span class="cov8" title="1">{
                                        level++
                                }</span> else<span class="cov8" title="1"> if char == ' ' </span><span class="cov8" title="1">{
                                        break</span>
                                } else<span class="cov0" title="0"> {
                                        level = 0
                                        break</span>
                                }
                                <span class="cov8" title="1">if i &gt;= 5 </span><span class="cov0" title="0">{ // Max 6 levels
                                        break</span>
                                }
                        }
                        
                        <span class="cov8" title="1">if level &gt; 0 &amp;&amp; level &lt;= 6 </span><span class="cov8" title="1">{
                                headerText := strings.TrimSpace(line[level:])
                                switch level </span>{
                                case 1:<span class="cov8" title="1">
                                        result = append(result, fmt.Sprintf("%s%s%s%s", Bold, BrightRed, headerText, Reset))</span>
                                case 2:<span class="cov8" title="1">
                                        result = append(result, fmt.Sprintf("%s%s%s%s", Bold, BrightBlue, headerText, Reset))</span>
                                case 3:<span class="cov8" title="1">
                                        result = append(result, fmt.Sprintf("%s%s%s%s", Bold, BrightYellow, headerText, Reset))</span>
                                case 4:<span class="cov0" title="0">
                                        result = append(result, fmt.Sprintf("%s%s%s%s", Bold, BrightGreen, headerText, Reset))</span>
                                case 5:<span class="cov0" title="0">
                                        result = append(result, fmt.Sprintf("%s%s%s%s", Bold, BrightMagenta, headerText, Reset))</span>
                                case 6:<span class="cov0" title="0">
                                        result = append(result, fmt.Sprintf("%s%s%s%s", Bold, BrightCyan, headerText, Reset))</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        }
                }
                <span class="cov8" title="1">result = append(result, line)</span>
        }
        
        <span class="cov8" title="1">return strings.Join(result, "\n")</span>
}

// renderBold converts **text** and __text__ to ANSI bold
func (r *MarkdownRenderer) renderBold(text string) string <span class="cov8" title="1">{
        // Handle **text**
        re := regexp.MustCompile(`\*\*([^*]+)\*\*`)
        text = re.ReplaceAllString(text, fmt.Sprintf("%s$1%s", Bold, Reset))
        
        // Handle __text__
        re = regexp.MustCompile(`__([^_]+)__`)
        text = re.ReplaceAllString(text, fmt.Sprintf("%s$1%s", Bold, Reset))
        
        return text
}</span>

// renderItalic converts *text* and _text_ to ANSI italic
func (r *MarkdownRenderer) renderItalic(text string) string <span class="cov8" title="1">{
        // Handle *text* (but not **text**)
        re := regexp.MustCompile(`(?:^|[^*])\*([^*]+)\*(?:[^*]|$)`)
        text = re.ReplaceAllString(text, fmt.Sprintf("$1%s$2%s$3", Italic, Reset))
        
        // Handle _text_ (but not __text__)
        re = regexp.MustCompile(`(?:^|[^_])_([^_]+)_(?:[^_]|$)`)
        text = re.ReplaceAllString(text, fmt.Sprintf("$1%s$2%s$3", Italic, Reset))
        
        return text
}</span>

// renderStrikethrough converts ~~text~~ to ANSI strikethrough (dim)
func (r *MarkdownRenderer) renderStrikethrough(text string) string <span class="cov8" title="1">{
        re := regexp.MustCompile(`~~([^~]+)~~`)
        text = re.ReplaceAllString(text, fmt.Sprintf("%s$1%s", Dim, Reset))
        return text
}</span>

// renderInlineCode converts `code` to ANSI formatted code
func (r *MarkdownRenderer) renderInlineCode(text string) string <span class="cov8" title="1">{
        re := regexp.MustCompile("`([^`]+)`")
        text = re.ReplaceAllString(text, fmt.Sprintf("%s%s$1%s", Yellow, Bold, Reset))
        return text
}</span>

// renderCodeBlocks converts ```code``` blocks to ANSI formatted code blocks
func (r *MarkdownRenderer) renderCodeBlocks(text string) string <span class="cov8" title="1">{
        // Handle fenced code blocks
        re := regexp.MustCompile("(?s)```([a-z]*)\n?(.*?)```")
        text = re.ReplaceAllStringFunc(text, func(match string) string </span><span class="cov8" title="1">{
                parts := re.FindStringSubmatch(match)
                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                        language := parts[1]
                        code := parts[2]
                        
                        // Add language label if present
                        result := ""
                        if language != "" </span><span class="cov8" title="1">{
                                result += fmt.Sprintf("%s%s[%s]%s\n", Dim, Cyan, language, Reset)
                        }</span>
                        
                        // Format the code block
                        <span class="cov8" title="1">codeLines := strings.Split(strings.TrimRight(code, "\n"), "\n")
                        for _, line := range codeLines </span><span class="cov8" title="1">{
                                result += fmt.Sprintf("%s%s%s%s\n", Dim, Yellow, line, Reset)
                        }</span>
                        
                        <span class="cov8" title="1">return result</span>
                }
                <span class="cov0" title="0">return match</span>
        })
        
        <span class="cov8" title="1">return text</span>
}

// renderLists converts markdown lists to formatted lists
func (r *MarkdownRenderer) renderLists(text string) string <span class="cov8" title="1">{
        lines := strings.Split(text, "\n")
        var result []string
        
        for _, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                
                // Unordered lists
                if strings.HasPrefix(trimmed, "- ") || strings.HasPrefix(trimmed, "* ") || strings.HasPrefix(trimmed, "+ ") </span><span class="cov8" title="1">{
                        content := trimmed[2:]
                        result = append(result, fmt.Sprintf("  %s•%s %s", BrightBlue, Reset, content))
                        continue</span>
                }
                
                // Ordered lists (basic detection)
                <span class="cov8" title="1">re := regexp.MustCompile(`^(\d+)\.\s+(.+)$`)
                if matches := re.FindStringSubmatch(trimmed); matches != nil </span><span class="cov8" title="1">{
                        number := matches[1]
                        content := matches[2]
                        result = append(result, fmt.Sprintf("  %s%s.%s %s", BrightBlue, number, Reset, content))
                        continue</span>
                }
                
                <span class="cov8" title="1">result = append(result, line)</span>
        }
        
        <span class="cov8" title="1">return strings.Join(result, "\n")</span>
}

// renderLinks converts [text](url) to colored text
func (r *MarkdownRenderer) renderLinks(text string) string <span class="cov8" title="1">{
        re := regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
        text = re.ReplaceAllString(text, fmt.Sprintf("%s%s$1%s %s(%s$2%s)", Underline, BrightCyan, Reset, Dim, BrightCyan, Reset))
        return text
}</span>

// renderBlockquotes converts &gt; text to formatted blockquotes
func (r *MarkdownRenderer) renderBlockquotes(text string) string <span class="cov8" title="1">{
        lines := strings.Split(text, "\n")
        var result []string
        
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.TrimSpace(line), "&gt; ") </span><span class="cov8" title="1">{
                        content := strings.TrimSpace(line)[2:]
                        result = append(result, fmt.Sprintf("%s%s│%s %s", Dim, BrightBlue, Reset, content))
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, line)</span>
        }
        
        <span class="cov8" title="1">return strings.Join(result, "\n")</span>
}

// stripMarkdown removes markdown formatting when colors are disabled
func (r *MarkdownRenderer) stripMarkdown(text string) string <span class="cov8" title="1">{
        // Remove headers
        re := regexp.MustCompile(`^#{1,6}\s+`)
        text = re.ReplaceAllString(text, "")
        
        // Remove bold
        re = regexp.MustCompile(`\*\*([^*]+)\*\*`)
        text = re.ReplaceAllString(text, "$1")
        re = regexp.MustCompile(`__([^_]+)__`)
        text = re.ReplaceAllString(text, "$1")
        
        // Remove italic
        re = regexp.MustCompile(`\*([^*]+)\*`)
        text = re.ReplaceAllString(text, "$1")
        re = regexp.MustCompile(`_([^_]+)_`)
        text = re.ReplaceAllString(text, "$1")
        
        // Remove strikethrough
        re = regexp.MustCompile(`~~([^~]+)~~`)
        text = re.ReplaceAllString(text, "$1")
        
        // Remove inline code
        re = regexp.MustCompile("`([^`]+)`")
        text = re.ReplaceAllString(text, "$1")
        
        // Remove code blocks
        re = regexp.MustCompile("(?s)```[a-z]*\n?(.*?)```")
        text = re.ReplaceAllString(text, "$1")
        
        // Remove links
        re = regexp.MustCompile(`\[([^\]]+)\]\([^)]+\)`)
        text = re.ReplaceAllString(text, "$1")
        
        // Clean up blockquotes
        lines := strings.Split(text, "\n")
        var result []string
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.TrimSpace(line), "&gt; ") </span><span class="cov8" title="1">{
                        content := strings.TrimSpace(line)[2:]
                        result = append(result, content)
                }</span> else<span class="cov8" title="1"> {
                        result = append(result, line)
                }</span>
        }
        <span class="cov8" title="1">text = strings.Join(result, "\n")
        
        return text</span>
}

// StreamingMarkdownRenderer handles real-time markdown rendering for streaming output
type StreamingMarkdownRenderer struct {
        renderer *MarkdownRenderer
        buffer   strings.Builder
        inCodeBlock bool
        codeBlockLang string
}

// NewStreamingMarkdownRenderer creates a new streaming markdown renderer
func NewStreamingMarkdownRenderer(colorOutput bool) *StreamingMarkdownRenderer <span class="cov8" title="1">{
        return &amp;StreamingMarkdownRenderer{
                renderer: NewMarkdownRenderer(colorOutput),
        }
}</span>

// ProcessChunk processes a chunk of streaming text and returns formatted output
func (sr *StreamingMarkdownRenderer) ProcessChunk(chunk string) string <span class="cov8" title="1">{
        // Add chunk to buffer
        sr.buffer.WriteString(chunk)
        
        // Get the current buffer content
        bufferContent := sr.buffer.String()
        
        // For streaming, we need to be careful about partial markdown syntax
        // Only process complete lines or complete markdown constructs
        
        lines := strings.Split(bufferContent, "\n")
        
        // If we don't have a complete line (no newline at end), keep the last part in buffer
        if !strings.HasSuffix(bufferContent, "\n") &amp;&amp; len(lines) &gt; 1 </span><span class="cov0" title="0">{
                processableLines := lines[:len(lines)-1]
                remainingContent := lines[len(lines)-1]
                
                if len(processableLines) == 0 </span><span class="cov0" title="0">{
                        return "" // Nothing to process yet
                }</span>
                
                // Process the complete lines
                <span class="cov0" title="0">processableText := strings.Join(processableLines, "\n") + "\n"
                rendered := sr.renderer.Render(processableText)
                
                // Reset buffer to remaining content
                sr.buffer.Reset()
                if remainingContent != "" </span><span class="cov0" title="0">{
                        sr.buffer.WriteString(remainingContent)
                }</span>
                
                <span class="cov0" title="0">return rendered</span>
        } else<span class="cov8" title="1"> if strings.HasSuffix(bufferContent, "\n") </span><span class="cov8" title="1">{
                // We have complete content ending with newline
                rendered := sr.renderer.Render(bufferContent)
                sr.buffer.Reset()
                return rendered
        }</span>
        
        // Buffer incomplete content
        <span class="cov8" title="1">return ""</span>
}

// Flush processes any remaining content in the buffer
func (sr *StreamingMarkdownRenderer) Flush() string <span class="cov8" title="1">{
        if sr.buffer.Len() == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">remaining := sr.buffer.String()
        sr.buffer.Reset()
        
        return sr.renderer.Render(remaining)</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "encoding/json"
        "log"
        "net/http"
        "strings"
)

// MockServer provides a simple mock OpenAI-compatible API for testing
type MockServer struct {
        server *http.Server
}

// ChatCompletionResponse represents the structure of a chat completion response
type ChatCompletionResponse struct {
        ID      string `json:"id"`
        Object  string `json:"object"`
        Created int64  `json:"created"`
        Model   string `json:"model"`
        Choices []struct {
                Index   int `json:"index"`
                Message struct {
                        Role    string `json:"role"`
                        Content string `json:"content"`
                } `json:"message"`
                FinishReason string `json:"finish_reason"`
        } `json:"choices"`
        Usage struct {
                PromptTokens     int `json:"prompt_tokens"`
                CompletionTokens int `json:"completion_tokens"`
                TotalTokens      int `json:"total_tokens"`
        } `json:"usage"`
}

// NewMockServer creates a new mock server
func NewMockServer(port string) *MockServer <span class="cov8" title="1">{
        mux := http.NewServeMux()
        mux.HandleFunc("/v1/chat/completions", handleChatCompletions)

        server := &amp;http.Server{
                Addr:    ":" + port,
                Handler: mux,
        }

        return &amp;MockServer{server: server}
}</span>

// Start starts the mock server
func (m *MockServer) Start() error <span class="cov8" title="1">{
        log.Printf("Starting mock server on %s", m.server.Addr)
        return m.server.ListenAndServe()
}</span>

// Stop stops the mock server
func (m *MockServer) Stop() error <span class="cov8" title="1">{
        return m.server.Close()
}</span>

// handleChatCompletions handles chat completions requests
func handleChatCompletions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Parse the request
        <span class="cov8" title="1">var req ChatRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Extract the user message
        <span class="cov8" title="1">var userMessage string
        for _, msg := range req.Messages </span><span class="cov8" title="1">{
                if msg.Role == "user" </span><span class="cov8" title="1">{
                        userMessage = msg.Content
                        break</span>
                }
        }

        // Generate a mock response based on the prompt
        <span class="cov8" title="1">responseContent := generateMockResponse(userMessage)

        // Create response
        response := ChatCompletionResponse{
                ID:      "chatcmpl-mock123",
                Object:  "chat.completion",
                Created: 1234567890,
                Model:   req.Model,
                Choices: []struct {
                        Index   int `json:"index"`
                        Message struct {
                                Role    string `json:"role"`
                                Content string `json:"content"`
                        } `json:"message"`
                        FinishReason string `json:"finish_reason"`
                }{
                        {
                                Index: 0,
                                Message: struct {
                                        Role    string `json:"role"`
                                        Content string `json:"content"`
                                }{
                                        Role:    "assistant",
                                        Content: responseContent,
                                },
                                FinishReason: "stop",
                        },
                },
                Usage: struct {
                        PromptTokens     int `json:"prompt_tokens"`
                        CompletionTokens int `json:"completion_tokens"`
                        TotalTokens      int `json:"total_tokens"`
                }{
                        PromptTokens:     10,
                        CompletionTokens: 20,
                        TotalTokens:      30,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// generateMockResponse generates a mock response based on the input
func generateMockResponse(prompt string) string <span class="cov8" title="1">{
        prompt = strings.ToLower(prompt)
        
        if strings.Contains(prompt, "hello") </span><span class="cov8" title="1">{
                return "Hello! How can I help you today?"
        }</span>
        <span class="cov8" title="1">if strings.Contains(prompt, "test") </span><span class="cov8" title="1">{
                return "This is a test response from the mock server."
        }</span>
        <span class="cov8" title="1">if strings.Contains(prompt, "markdown") </span><span class="cov8" title="1">{
                return "# Markdown Response\n\nThis is a **bold** response with *italic* text and `code`."
        }</span>
        
        <span class="cov8" title="1">return "This is a mock response to: " + prompt</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"
)

// ChatMessage represents a message in a chat conversation
type ChatMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// ChatRequest represents a request to a chat completion API
type ChatRequest struct {
        Model       string        `json:"model"`
        Messages    []ChatMessage `json:"messages"`
        Temperature float64       `json:"temperature,omitempty"`
        Stream      bool          `json:"stream,omitempty"`
}

// ChatResponse represents a response from a chat completion API
type ChatResponse struct {
        Choices []struct {
                Message struct {
                        Content string `json:"content"`
                } `json:"message"`
        } `json:"choices"`
}

// HTTPClient interface for dependency injection
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// defaultHTTPClient is the default HTTP client
var defaultHTTPClient HTTPClient = &amp;http.Client{
        Timeout: 30 * time.Second,
}

// getMockServerURL returns the mock server URL if in test mode
func getMockServerURL() string <span class="cov8" title="1">{
        if os.Getenv("GPT_CLI_TEST") == "1" </span><span class="cov8" title="1">{
                // Allow override via environment variable
                if mockURL := os.Getenv("MOCK_SERVER_URL"); mockURL != "" </span><span class="cov8" title="1">{
                        return mockURL
                }</span>
                <span class="cov8" title="1">return "http://127.0.0.1:8086"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// callOpenAIProvider calls the OpenAI API
func callOpenAIProvider(config *CoreConfig, opts *ProviderOptions) (*ProviderResponse, error) <span class="cov8" title="1">{
        baseURL := "https://api.openai.com"
        if opts.BaseURL != "" </span><span class="cov8" title="1">{
                baseURL = opts.BaseURL
        }</span>
        <span class="cov8" title="1">if mockURL := getMockServerURL(); mockURL != "" </span><span class="cov8" title="1">{
                baseURL = mockURL
        }</span>

        <span class="cov8" title="1">return callOpenAICompatibleAPI(baseURL, config, opts)</span>
}

// callCopilotProvider calls the GitHub Copilot API
func callCopilotProvider(config *CoreConfig, opts *ProviderOptions) (*ProviderResponse, error) <span class="cov8" title="1">{
        baseURL := "https://api.github.com"
        if opts.BaseURL != "" </span><span class="cov8" title="1">{
                baseURL = opts.BaseURL
        }</span>
        <span class="cov8" title="1">if mockURL := getMockServerURL(); mockURL != "" </span><span class="cov8" title="1">{
                baseURL = mockURL
        }</span>

        <span class="cov8" title="1">return callOpenAICompatibleAPI(baseURL, config, opts)</span>
}

// callGeminiProvider calls the Google Gemini API
func callGeminiProvider(config *CoreConfig, opts *ProviderOptions) (*ProviderResponse, error) <span class="cov0" title="0">{
        // For now, use the same OpenAI-compatible interface
        // TODO: Implement proper Gemini API calls
        baseURL := "https://generativelanguage.googleapis.com"
        if opts.BaseURL != "" </span><span class="cov0" title="0">{
                baseURL = opts.BaseURL
        }</span>
        <span class="cov0" title="0">if mockURL := getMockServerURL(); mockURL != "" </span><span class="cov0" title="0">{
                baseURL = mockURL
        }</span>

        <span class="cov0" title="0">return callOpenAICompatibleAPI(baseURL, config, opts)</span>
}

// callOpenAICompatibleAPI makes a call to an OpenAI-compatible API
func callOpenAICompatibleAPI(baseURL string, config *CoreConfig, opts *ProviderOptions) (*ProviderResponse, error) <span class="cov8" title="1">{
        // Build chat request
        messages := []ChatMessage{}
        
        if config.System != "" </span><span class="cov8" title="1">{
                messages = append(messages, ChatMessage{
                        Role:    "system",
                        Content: config.System,
                })
        }</span>
        
        <span class="cov8" title="1">messages = append(messages, ChatMessage{
                Role:    "user",
                Content: config.Prompt,
        })

        request := ChatRequest{
                Model:       config.Model,
                Messages:    messages,
                Temperature: config.Temperature,
                Stream:      false, // Non-streaming for now
        }

        // Marshal request to JSON
        requestBody, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov8" title="1">url := baseURL + "/v1/chat/completions"
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(requestBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        if opts.APIKey != "" </span><span class="cov8" title="1">{
                req.Header.Set("Authorization", "Bearer "+opts.APIKey)
        }</span>

        // Make the request
        <span class="cov8" title="1">resp, err := defaultHTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Check for non-200 status
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse response
        <span class="cov8" title="1">var chatResp ChatResponse
        if err := json.Unmarshal(body, &amp;chatResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        // Extract content
        <span class="cov8" title="1">if len(chatResp.Choices) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no choices in response")
        }</span>

        <span class="cov8" title="1">content := chatResp.Choices[0].Message.Content

        return &amp;ProviderResponse{
                Text:     content,
                Markdown: content, // For now, treat content as both text and markdown
        }, nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "strings"
)

// StreamingResponse represents a chunk from a streaming response
type StreamingResponse struct {
        ID      string `json:"id"`
        Object  string `json:"object"`
        Created int64  `json:"created"`
        Model   string `json:"model"`
        Choices []struct {
                Index int `json:"index"`
                Delta struct {
                        Content string `json:"content"`
                } `json:"delta"`
                FinishReason *string `json:"finish_reason"`
        } `json:"choices"`
}

// streamChatCompletion handles streaming chat completions
func streamChatCompletion(config *CoreConfig, opts *ProviderOptions) error <span class="cov8" title="1">{
        baseURL := getProviderBaseURL(config.Provider, opts)
        
        // Build the request
        messages := []ChatMessage{}
        if config.System != "" </span><span class="cov8" title="1">{
                messages = append(messages, ChatMessage{
                        Role:    "system",
                        Content: config.System,
                })
        }</span>
        <span class="cov8" title="1">messages = append(messages, ChatMessage{
                Role:    "user",
                Content: config.Prompt,
        })

        request := ChatRequest{
                Model:       config.Model,
                Messages:    messages,
                Temperature: config.Temperature,
                Stream:      true,
        }

        // Marshal request
        requestBody, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov8" title="1">url := baseURL + "/v1/chat/completions"
        req, err := http.NewRequest("POST", url, strings.NewReader(string(requestBody)))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "text/event-stream")
        req.Header.Set("Cache-Control", "no-cache")
        if opts.APIKey != "" </span><span class="cov8" title="1">{
                req.Header.Set("Authorization", "Bearer "+opts.APIKey)
        }</span>

        // Make the request
        <span class="cov8" title="1">resp, err := defaultHTTPClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("API returned status %d", resp.StatusCode)
        }</span>

        // Initialize streaming markdown renderer if markdown is enabled
        <span class="cov8" title="1">var streamRenderer *StreamingMarkdownRenderer
        if config.UseMarkdown </span><span class="cov8" title="1">{
                streamRenderer = NewStreamingMarkdownRenderer(true)
        }</span>

        // Process streaming response
        <span class="cov8" title="1">scanner := bufio.NewScanner(resp.Body)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                
                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, ":") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse SSE data
                <span class="cov8" title="1">if strings.HasPrefix(line, "data: ") </span><span class="cov0" title="0">{
                        data := strings.TrimPrefix(line, "data: ")
                        
                        // Check for end of stream
                        if data == "[DONE]" </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Parse the JSON chunk
                        <span class="cov0" title="0">var chunk StreamingResponse
                        if err := json.Unmarshal([]byte(data), &amp;chunk); err != nil </span><span class="cov0" title="0">{
                                if config.Verbose </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Failed to parse chunk: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Output the content
                        <span class="cov0" title="0">if len(chunk.Choices) &gt; 0 &amp;&amp; chunk.Choices[0].Delta.Content != "" </span><span class="cov0" title="0">{
                                content := chunk.Choices[0].Delta.Content
                                
                                if config.UseMarkdown &amp;&amp; streamRenderer != nil </span><span class="cov0" title="0">{
                                        // Process through streaming markdown renderer
                                        rendered := streamRenderer.ProcessChunk(content)
                                        if rendered != "" </span><span class="cov0" title="0">{
                                                fmt.Print(rendered)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Output raw content
                                        fmt.Print(content)
                                }</span>
                        }
                }
        }

        // Flush any remaining content from the streaming renderer
        <span class="cov8" title="1">if config.UseMarkdown &amp;&amp; streamRenderer != nil </span><span class="cov8" title="1">{
                if remaining := streamRenderer.Flush(); remaining != "" </span><span class="cov0" title="0">{
                        fmt.Print(remaining)
                }</span>
        }

        // Add final newline
        <span class="cov8" title="1">fmt.Println()
        
        return scanner.Err()</span>
}

// getProviderBaseURL returns the base URL for a provider
func getProviderBaseURL(provider string, opts *ProviderOptions) string <span class="cov8" title="1">{
        if opts.BaseURL != "" </span><span class="cov8" title="1">{
                return opts.BaseURL
        }</span>
        
        <span class="cov8" title="1">if mockURL := getMockServerURL(); mockURL != "" </span><span class="cov8" title="1">{
                return mockURL
        }</span>

        <span class="cov8" title="1">provider = strings.ToLower(provider)
        switch provider </span>{
        case "openai":<span class="cov8" title="1">
                return "https://api.openai.com"</span>
        case "copilot":<span class="cov8" title="1">
                return "https://api.github.com"</span>
        case "gemini":<span class="cov8" title="1">
                return "https://generativelanguage.googleapis.com"</span>
        default:<span class="cov8" title="1">
                return "https://api.openai.com"</span>
        }
}

// updateTryStreamingProvider to use the new streaming implementation
func tryStreamingProvider(config *CoreConfig, providerOpts *ProviderOptions) error <span class="cov8" title="1">{
        return streamChatCompletion(config, providerOpts)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "strings"
)

// SuggestionResponse represents the JSON structure for shell suggestions
type SuggestionResponse struct {
        Suggestions []Suggestion `json:"suggestions"`
        Context     string       `json:"context,omitempty"`
        Safe        bool         `json:"safe"`
}

// Suggestion represents a single shell command suggestion
type Suggestion struct {
        Command     string   `json:"command"`
        Description string   `json:"description"`
        Category    string   `json:"category,omitempty"`
        Risk        string   `json:"risk"` // "low", "medium", "high"
        Args        []string `json:"args,omitempty"`
}

// generateSuggestionPrompt creates a specialized system prompt for shell suggestions
func generateSuggestionPrompt() string <span class="cov8" title="1">{
        return `You are a shell command assistant. Your task is to suggest shell commands based on user requests.

CRITICAL RULES:
1. Output ONLY valid JSON in the exact format specified below
2. Never suggest commands that could be dangerous (rm -rf, dd, formatting commands, etc.)
3. Mark risk levels appropriately: "low" for safe commands, "medium" for commands that modify files, "high" for potentially dangerous commands
4. Provide 1-3 relevant suggestions maximum
5. Include clear descriptions of what each command does

Output format (JSON only, no markdown, no extra text):
{
  "suggestions": [
    {
      "command": "actual shell command",
      "description": "clear explanation of what this does", 
      "category": "file_management|system_info|network|development|etc",
      "risk": "low|medium|high",
      "args": ["arg1", "arg2"]
    }
  ],
  "context": "brief context about the task",
  "safe": true/false
}

Example request: "list files in current directory"
Example response:
{
  "suggestions": [
    {
      "command": "ls -la",
      "description": "List all files and directories with detailed information including hidden files",
      "category": "file_management", 
      "risk": "low",
      "args": ["-la"]
    }
  ],
  "context": "Listing directory contents",
  "safe": true
}`
}</span>

// parseSuggestionResponse parses the AI response and validates it as suggestion JSON
func parseSuggestionResponse(response string) (*SuggestionResponse, error) <span class="cov8" title="1">{
        // Clean up the response - remove any markdown formatting
        cleaned := strings.TrimSpace(response)
        
        // Remove markdown code blocks if present
        if strings.HasPrefix(cleaned, "```json") </span><span class="cov8" title="1">{
                cleaned = strings.TrimPrefix(cleaned, "```json")
                cleaned = strings.TrimSuffix(cleaned, "```")
                cleaned = strings.TrimSpace(cleaned)
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(cleaned, "```") </span><span class="cov0" title="0">{
                cleaned = strings.TrimPrefix(cleaned, "```")
                cleaned = strings.TrimSuffix(cleaned, "```")
                cleaned = strings.TrimSpace(cleaned)
        }</span>
        
        <span class="cov8" title="1">var suggestions SuggestionResponse
        if err := json.Unmarshal([]byte(cleaned), &amp;suggestions); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse suggestion response as JSON: %w", err)
        }</span>
        
        // Validate the response
        <span class="cov8" title="1">if len(suggestions.Suggestions) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no suggestions found in response")
        }</span>
        
        // Validate each suggestion
        <span class="cov8" title="1">for i, suggestion := range suggestions.Suggestions </span><span class="cov8" title="1">{
                if suggestion.Command == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("suggestion %d has empty command", i)
                }</span>
                <span class="cov8" title="1">if suggestion.Description == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("suggestion %d has empty description", i)
                }</span>
                <span class="cov8" title="1">if suggestion.Risk == "" </span><span class="cov8" title="1">{
                        suggestions.Suggestions[i].Risk = "medium" // Default to medium risk
                }</span>
        }
        
        <span class="cov8" title="1">return &amp;suggestions, nil</span>
}

// formatSuggestionOutput formats the suggestions for console output
func formatSuggestionOutput(suggestions *SuggestionResponse) string <span class="cov8" title="1">{
        output, err := json.MarshalIndent(suggestions, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"error": "failed to format suggestions: %v"}`, err)
        }</span>
        <span class="cov8" title="1">return string(output)</span>
}

// runSuggestionMode runs the CLI in shell suggestion mode
func runSuggestionMode(config *CoreConfig, providerOpts *ProviderOptions) error <span class="cov8" title="1">{
        // Override system prompt for suggestions
        originalSystem := config.System
        config.System = generateSuggestionPrompt()
        
        // Disable streaming for suggestions to get complete JSON response
        originalStream := config.Stream
        config.Stream = false
        
        // Get the response from the provider
        response, err := callProvider(config, providerOpts)
        if err != nil </span><span class="cov0" title="0">{
                // Restore original config
                config.System = originalSystem
                config.Stream = originalStream
                return err
        }</span>
        
        // Restore original config
        <span class="cov8" title="1">config.System = originalSystem
        config.Stream = originalStream
        
        // Choose the response text (prefer markdown for richer content)
        responseText := response.Markdown
        if responseText == "" </span><span class="cov0" title="0">{
                responseText = response.Text
        }</span>
        
        // Parse and validate the suggestion response
        <span class="cov8" title="1">suggestions, err := parseSuggestionResponse(responseText)
        if err != nil </span><span class="cov8" title="1">{
                // If parsing fails, return a safe error response
                errorResponse := &amp;SuggestionResponse{
                        Suggestions: []Suggestion{
                                {
                                        Command:     "echo 'Unable to generate safe suggestions'",
                                        Description: "The AI was unable to generate safe command suggestions for your request",
                                        Category:    "error",
                                        Risk:        "low",
                                        Args:        []string{"'Unable to generate safe suggestions'"},
                                },
                        },
                        Context: "Error parsing AI response",
                        Safe:    true,
                }
                fmt.Print(formatSuggestionOutput(errorResponse))
                return nil
        }</span>
        
        // Output the formatted suggestions
        <span class="cov0" title="0">fmt.Print(formatSuggestionOutput(suggestions))
        return nil</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "fmt"
        "net"
        "time"
)

// TestServer wraps a mock server for testing
type TestServer struct {
        mockServer *MockServer
        URL        string
}

func (ts *TestServer) Close() <span class="cov8" title="1">{
        if ts.mockServer != nil </span><span class="cov8" title="1">{
                ts.mockServer.Stop()
        }</span>
}

// startMockTestServer starts a mock server for testing
func startMockTestServer() *TestServer <span class="cov8" title="1">{
        // Find an available port
        listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">port := listener.Addr().(*net.TCPAddr).Port
        listener.Close()
        
        // Create mock server
        mockServer := NewMockServer(fmt.Sprintf("%d", port))
        
        // Start server in background
        go func() </span><span class="cov8" title="1">{
                mockServer.Start()
        }</span>()
        
        // Give server time to start
        <span class="cov8" title="1">time.Sleep(100 * time.Millisecond)
        
        url := fmt.Sprintf("http://127.0.0.1:%d", port)
        return &amp;TestServer{
                mockServer: mockServer,
                URL:        url,
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
